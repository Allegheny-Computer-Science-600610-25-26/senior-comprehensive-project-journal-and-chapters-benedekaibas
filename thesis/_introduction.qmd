---
title: "Chapter One of My Senior Thesis"
date: "2025-10-11"
---

# Introduction

According to StackOverflow, IEEE, and other surveys Python has became the most popular programming language by 2025. We can see that Python programming language
is used in various fields, such as: web development, enterprise, embedded domains, machine learning, and artificial intelligence. However, Python suffers from runtime
errors. The leading runtime errors are type related errors. Type error happens when an operation is performed on a value of an unsupported type.

```{ython}
def foo(number: int) -> int:
  """Return the input as a squared number."""
  return "The squared number is: ", number**2
```

In this case even though the programmer wanted to return a nice way of representing the squared input number type error occured. Since in the function declaration it is 
stated that the return type of this function has to be an integer the following implementation is wrong, because it returns a tuple that contains string and integer.

To catch these type related errors in large code bases type checkers can provide a significant amount of help. Type checkers can detect type related errors in Python programs
statically which means developers do not have to run the programs in order to see, if there is an error in their program. However, static analyzer are not perfect and they can
produce false positive and false negative reports.

By definition false positive means that the static analyer reported an error that is not an actual bug in the code.

```{python}
from enum import Enum, member
from typing import reveal_type

class E(Enum):
  @member
  def A() -> int:
    return 1

assert E.A.value() == 1
reveal_type(E.A)
reveal_type(E.A.value)
```

```{text}
fp01.py:6: error: Method must have at least one argument. Did you forget the "self" argument?
```

This is a typical case where the type checker (mypy with version: 1.18.2) provided a false positive report. This issue got later fixed in the mypy type checker.
False positives cause time overhead in terms of overviewing a code that is actually correct, so by reducing false positive reports in type checkers will lead to
the point where programmers have to spend less time dealing with false positive reports and more time on fixing actual bugs.

When a program has a bug in it, but the static analyzer misses catching it that case called false negative report. In this case the type checker(s) missed a bug that
was indeed in the program's code. This is a serious issue because, if this bug does not get detected by static analyzers and neither test cases and goes to production
that can cause bugs in the given system, service, etc. where the code is used.

```{python}
from typing import Protocol

class CanHex(Protocol):
  def hex(self, /) -> str: ...

int_does_not_have_hex: CanHex = 959
bool_does_not_have_hex: CanHex = False
```

```{text}
Success: no issues found in 1 source file
```

This example were taken from a real example where the mypy type checker with the 1.13 version missed detecting the bug. This issue got later resolved as well as the false positive case!

Through these examples it is clear that in software engineering static analyzers play a crucial role, but -just as any other tools- they have their cons as well.

My goal with this research is to provide feedback for developer teams working on these type checkers on where their type checkers should be improved and also provide an automated tool that 
generates new, uncovered examples that are able to trigger type checkers to provide false reports.

## Motivation



## Research Goals

My research paper aims to provide a tool that can automatically generate code examples that would force the type checkers to report false negatives, false positives, and valid reports.
Then it would be able to determine which type checkers were correct. Based on this information my research paper will evaluate the different type checkers, suggest what changes would
be needed for type checkers, and provide code examples that are introducing new cases where type checkers' reports are false.
