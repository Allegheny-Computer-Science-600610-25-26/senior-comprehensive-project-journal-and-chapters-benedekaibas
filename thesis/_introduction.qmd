---
title: "Chapter One of My Senior Thesis"
date: "2025-10-11"
---

# Introduction

According to StackOverflow, IEEE, and other surveys Python has became the most popular programming language by 2025. We can see that Python programming language
is used in various fields, such as: web development, enterprise, embedded domains, machine learning, and artificial intelligence. However, Python suffers from runtime
errors. The leading runtime errors are type related errors. Type error happens when an operation is performed on a value of an unsupported type.

```{ython}
def foo(number: int) -> int:
  """Return the input as a squared number."""
  return "The squared number is: ", number**2
```

In this case even though the programmer wanted to return a nice way of representing the squared input number type error occured. Since in the function declaration it is 
stated that the return type of this function has to be an integer the following implementation is wrong, because it returns a tuple that contains string and integer.

To catch these type related errors in large code bases type checkers can provide a significant amount of help. Type checkers can detect type related errors in Python programs
statically which means developers do not have to run the programs in order to see, if there is an error in their program. However, static analyzer are not perfect and they can
produce false positive and false negative reports.

By definition false positive means that the static analyer reported an error that is not an actual bug in the code.

```{python}
from enum import Enum, member
from typing import reveal_type

class E(Enum):
  @member
  def A() -> int:
    return 1

assert E.A.value() == 1
reveal_type(E.A)
reveal_type(E.A.value)
```

```{text}
fp01.py:6: error: Method must have at least one argument. Did you forget the "self" argument?
```

This is a typical case where the type checker (mypy with version: 1.18.2) provided a false positive report. This issue got later fixed in the mypy type checker.
False positives cause time overhead in terms of overviewing a code that is actually correct, so by reducing false positive reports in type checkers will lead to
the point where programmers have to spend less time dealing with false positive reports and more time on fixing actual bugs.

When a program has a bug in it, but the static analyzer misses catching it that case called false negative report. In this case the type checker(s) missed a bug that
was indeed in the program's code. This is a serious issue because, if this bug does not get detected by static analyzers and neither test cases and goes to production
that can cause bugs in the given system, service, etc. where the code is used.

```{python}

```


## Problem We Face and The Importance of It

Type related errors are the leading errors in Python programming language according to (Oh & Oh, 2022). We have static analysis toolsets that are
scanning our source code and without running it they produce analysis. The feedback of these static analysis tools or type checkers is important for
developers to determine, if their code has type related errors. However, these type checkers are not working perfectly and they tend to produce false positive
or false negative reports. On the same source code different type checkers can produce different reports. The problem we have right now is that we do not
know which type checker's report is valid without going to the source code and analyze it by ourselves.

Also if we encounter a false report in a type checker it only happens, if someone's code resulted in a false positive or false negative report from a type checker,
but that requires writing codes and running at least one type checker on that source code. If someone has a code that would lead to a false report, but does not use
type checker analysis on the source code then we will never know about it.

## Motivation

Right now, we face many difficulties about type checkers. We do not have an automated way of generating code examples that would force type checkers to produce
false reports. Also we have to wait for someone to submit an issue with code example that leads to a false case in a type checker, but even if that happens we have to
manually visit other type checkers, run those type checkers on the example and see their output.

For conclusion, we can clearly say that we need a program that does all this for us in an automated way, so we can encounter many different and new logics that trigger
type checkers and force them to give false reports. Also we would need the same program to automatically evaluate the report of different type checkers.

If we have a program like I described then improving the accuracy of type checkers would be way faster and more reliable. It would also be possible to see how type checkers
work on new features that are recently included in Python or will be included in later releases. By that we would be able to keep type checkers up to date with the newest
versions of the Python programming language.

## Research Goals

My research paper aims to provide a tool that can automatically generate code examples that would force the type checkers to report false negatives, false positives, and valid reports.
Then it would be able to determine which type checkers were correct. Based on this information my research paper will evaluate the different type checkers, suggest what changes would
be needed for type checkers, and provide code examples that are introducing new cases where type checkers' reports are false.
